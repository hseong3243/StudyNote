#### 프로세스
---
프로세스란 저장장치에 저장된 정적인 상태의 프로그램이 실행을 위해 메모리에 올라온 동적인 상태를 프로세스라고 합니다.

##### 프로세스 제어 블럭(PCB)
프로세스가 메모리에 올라오면 프로세스를 처리하기 위한 다양한 정보가 들어있는 PCB가 만들어집니다. PCB는 OS가 해당 프로세스를 실행하기 위해 관리하는 데이터 구조이므로 운영체제 영역에 만들어지게 됩니다. 프로세스가 종료되면 PCB 역시 폐기됩니다.

PCB에 포함되어 있는 정보는 다음과 같은 것들이 있습니다.

- 프로세스 구분자(PID): 메모리에 있는 여러 개의 프로세스를 구분합니다.
- 메모리 관련 정보: 메모리 위치 정보, 메모리 보호를 위한 경계 레지스터, 한계 레지스터
- 각종 중간값: 다음에 실행할 명령어 주소를 저장하는 프로그램 카운터, 각종 중간값을 보관중인 레지스터들

##### 프로세스 상태
프로세스 상태는 다섯 가지 상태로 구분됩니다.

- 생성 상태
	생성 상태는 프로그램이 메모리에 올라오고 운영체제로부터 PCB를 할당받은 상태입니다.
- 준비 상태
	준비 상태는 실행 대기 중인 프로세스가 자기 순서를 기다리는 상태입니다. PCB는 준비 큐에서 기다리며 CPU 스케줄러에 의해 관리됩니다.
- 실행 상태
	프로세스가 CPU를 할당받아 실행되는 상태입니다. 주어진 타임 슬라이스동안 작업하다가 시간을 모두 소모하면 준비 상태로 옮겨집니다. 만약 작업이 완료되면 프로세스가 정상 종료됩니다.
- 대기 상태
	실행 상태의 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태입니다. 입출력이 완료되면 인터럽트가 발생하여 해당 인터럽트를 발생시킨 프로세스의 PCB를 준비 상태로 이동시킵니다.
- 완료 상태
	프로세스가 종료된 상태입니다. 모든 자원은 반납되고 PCB를 폐기합니다.

이 외에 프로세스가 작업을 쉬고 있는 휴식 상태와 메모리에서 잠시 쫓겨난 보류 상태가 있습니다.

##### 문맥 교환(Context switch)
문맥 교환은 CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말합니다. 나가는 PCB에는 지금까지의 작업 내용을 저장하고, 실행 상태로 들어오는 PCB의 내용을 읽어서 상태를 복구하는 작업이 이루어집니다.

##### 프로세스의 구조
프로세스는 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 구성되어 있습니다.

- 코드 영역
	코드 영역은 프로그램의 코드가 저장되는 영역입니다.
- 데이터 영역
	데이터 영역은 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아놓은 곳입니다.
- 스택 영역
	스택 영역은 함수 호출 시 생성되는 지역 변수와 매개 변수, 되돌아올 주소를 저장하는 영역입니다.
- 힙 영역
	힙 영역은 프로그래머가 직접 메모리를 할당하고 해제하는 영역입니다.

##### fork()
fork() 시스템 호출은 커널에서 제공하는 함수로 실행 주인 프로세스로부터 새로운 프로세스를 복사합니다. 이때 실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스가 됩니다.

PCB의 내용 중 PID가 변경되고 메모리 관련 정보가 변경됩니다. 부모 프로세스는 자식 프로세스 구분자(CPID)가 변경되고 자식 프로세스는 부모 프로세스 구분자(PPID)가 변경됩니다.

##### exec()
exec() 시스템 호출은 기존 프로세스를 새로운 프로세스로 전환하는 함수입니다. 이미 만들어진 PCB, 메모리 영역, 부모-자식 관계는 남겨두고 프로세스 나머지 내용을 새로운 것으로 바꿉니다.

fork()와 exec()을 통해 만들어진 프로세스 계층 구조는 다음과 같은 장점을 가집니다.

- 여러 작업의 동시 처리
	여러 사용자를 동시에 처리하기 위해 fork()를 호출하여 여러 개의 login 프로세스를 만들어 사용자에게 나누어줍니다. 이러한 작업의 반복을 통해 여러 사용자를 동시에 처리할 수 있습니다.
	login 프로세스가 종료되면 exec()을 호출하여 login 프로세스의 구조를 shell 프로세스로 재활용하여 자원을 효율적으로 관리할 수 있습니다.
- 용이한 자원 회수
	프로세스 간의 책임 관계가 분명해져 시스템을 관리하기 수월합니다. 자식 프로세스가 작업을 마치면 사용하던 자원을 부모 프로세스가 회수하면 됩니다.

##### 고아 프로세스와 좀비 프로세스
고아 프로세스는 자식 프로세스가 종료되기 전에 부모 프로세스가 먼저 종료되어 남은 자식 프로세스를 말합니다. 좀비 프로세스는 자식 프로세스가 종료되었는데도 부모 프로세스가 자원을 회수하지 않은 자식 프로세스를 말합니다.

고아 프로세스와 자식 프로세스가 많아지면 자원이 낭비되기 때문에 운영체제는 주기적으로 반환되지 못한 자원을 회수해야 합니다.

