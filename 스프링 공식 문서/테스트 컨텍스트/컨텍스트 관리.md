스프링 부트는 `@SpringBootTest` 어노테이션을 제공함으로서 표준 spring-test `@ContextConfiguration` 어노테이션을 대체할 수 있습니다.
`@SpringBootTest`는 `SpringApplication`을 통해 테스트에 사용되는 `ApplicationContext`를 생성하는 방식으로 작동합니다.

기본적으로 `@SpringBootTest`는 서버를 시작하지 않습니다. 따라서 `@SpringBootTest`의 `webEnvironment` 속성을 사용하여 테스트 실행 방식을 변경할 수 있습니다. 속성 값으로는 다음과 같습니다.

- `MOCK`: 웹 `ApplicationContext`를 로드하고 목 웹 환경을 제공합니다. 임베디드 서버는 시작되지 않습니다.
- `RANDOM_PORT`: `WebServerApplicationContext`를 로드하고 실제 웹 환경을 제공합니다. 임베디드 서버가 시작되고 랜덤한 포트를 listen합니다.
- `DEFINED_PORT`: `WebServerApplicationContext`를 로드하고 실제 웹 환경을 제공합니다. 임베디드 서버가 시작되고 사용자가 정의한 포트 또는 디폴트 포트인 8080을 listen합니다.
- `NONE`: `SpringApplication`을 이용하여 `ApplicationContext`를 로드합니다. 하지만 어떠한 웹 환경도 제공하지 않습니다.

### 테스트 설정 감지
스프링 부트 애플리케이션을 테스트하는 경우 `@*Test` 어노테이션은 명시적으로 configuration을 정의하지 않은 경우 기본 configuration을 자동으로 검색합니다.
만일 configuration을 커스텀하고자 한다면 nested  `@TestConfiguration` 클래스를 사용할 수 있습니다. nested `@TestConfiguration`을 사용하는 경우 애플리케이션의 기본 구성에 추가로 사용됩니다.

### Context Caching
TestContext 프레임워크가  테스트를 위해 `ApplicationContext`를 로드하면 해당 컨텍스트는 캐시됩니다. 이때 해당 컨텍스트는 동일한 테스트 스위트내에서 동일한 고유 컨텍스트 configuration을 선언하는 모든 후속 테스트에 재사용됩니다.
캐싱의 작동 방식을 이해하기 위해서는 "고유(unique)"와 "테스트 스위트(test suite)"의 의미를 이해해야 합니다.

`ApplicationContext`는 이를 로드하는데 사용되는 configuration 파라미터의 조합을 통해 고유하게 식별할 수 있습니다. 즉, 해당 조합은 컨텍스트가 캐시되는 key를 생성하는데 사용됩니다.

스프링 테스트 컨텍스트 프레임워크는 애플리케이션 컨텍스트를 정적 캐시에 저장합니다. 이는 컨텍스트가 말 그대로 정적 변수에 저장된다는 의미라고 합니다. 만일 캐싱된 컨텍스트를 효율적으로 사용하고 한다면 모든 테스트가 동일한 프로세스 내부에서 수행되어야 합니다.

컨텍스트 캐시의 크기는 기본적으로 최대 32로 제한됩니다. 최대 크기에 도달할 때마다 LRU(lest recently used) 정책에 따라 가장 오래된 컨텍스트를 제거한다고 합니다. 최대 크기는 properties를 통해 별도로 설정해줄 수 있다고 합니다.

하나의 프로세스 내에서 애플리케이션 컨텍스트가 반복적으로 로드되면 테스트를 수행하는데 불필요하게 오랜 시간이 소모될 수 있습니다. 때문에 로드 및 캐싱된 컨텍스트의 수를 정확히 아는 것이 유용할 때가 많습니다.

만일 테스트가 애플리케이션 컨텍스트를 파괴하는 경우 캐싱된 컨텍스트를 지우고 다시 로드하도록 할 수 있습니다. 이 경우 테스트 클래스/메서드에 `@DirtiesContext`를 추가하면 됩니다.

Spring의 테스트 프레임워크는 테스트 간에 애플리케이션 컨텍스트를 캐시하고 동일한 구성을 공유하는 테스트간에 컨텍스트를 재사용합니다. 하지만 `@MockBean` 또는 `@SpyBean`을 사용하면 캐시 key에 영향을 미치므로 컨텍스트 수가 늘어날 가능성이 높습니다.