- B-Tree의 B는 Balanced를 의미한다.
- 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.
- 대부분 인덱스는 거의 B-Tree를 사용한다.

## 구조 및 특성
---
- 트리 구조의 최상위에 하나의 "루트 노드(Root node)"가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다.
- 트리 구조의 가장 하위에 있는 노드를 "리프 노드(Leaf Node)"라 하고, 중간의 노드를 "브랜치 노드(Branch node)"라고 한다.
- 인덱스와 실제 데이터가 저장된 데이터는 따로 관리된다.
- 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

- InnoDB 테이블은 프라이머리 키를 주소처럼 사용한다.
- 떄문에 인덱스에 저장되어 있는 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후, 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
- 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 다시 한번 검색해야 한다.

## B-Tree 인덱스 키 추가 및 삭제
---
### 인덱스 키 추가
- 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색한다.
- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다.
- 리프 노드가 꽉 차서 더는 저장할 수 없는 경우 리프 노드가 분리(split)돼야 한다. 이 경우 상위 브랜치 노드까지 처리 범위가 넓어진다.
- 이 때문에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다.
