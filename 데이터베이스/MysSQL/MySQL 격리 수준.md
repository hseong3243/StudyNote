격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다.

4개의 격리 수준에서 뒤로 갈수록 트랜잭션 간 데이터 격리 정도가 높이지며, 동시 처리 성능이 떨어진다. 하지만 SERIALIZABLE 수준이 아니면 크게 성능의 개선이나 저하는 발생하지 않는다.

오라클 같은 DBMS는 주로 READ COMMITTED 수준을, MySQL에서는 주로 REPEATABLE READ를 사용한다.

### READ UNCOMMITTED
---
각 트랜잭션에서의 변경 내용이 `commit`, `rollback` 여부에 상관없이 다른 트랜잭션에서 보인다.
문제는 사용자 A의 트랜잭션 도중 `insert` 한 `LaLa`를 롤백하더라도 사용자 B는 `LaLa`를 정상적인 데이터라 생각하고 계속 처리하게 된다.

이처럼 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상을 **더티 리드(Dirty read)** 라고 한다.

### READ COMMITTED
---
오라클 DBMS에서 기본으로 사용되는 격리 수준으로 온라인 서비스에서 가장 많이 선택되는 격리 수준이다. 어떤 트랜잭션에서 데이터를 변경했더라도 `commit`이 완료된 데이터마 다른 트랜잭션에서 조회할 수 있다.

사용자 A가 `LaLa`를 `Toto`로 변경했을 때 `Toto`는 테이블에 즉시 기록되고 이전 값인  `Lara`는 언두 영역으로 백업된다. 사용자 A가 `commit` 전에 사용자 B가 해당 레코드를 조회하면 `first_name` 컬럼의 값은 `Lara`로 조회된다.

최종적으로 사용자 A가 변경된 내용을 커밋하면 그때부터는 다른 트랜잭션에서도 새롭게 변경된 `Toto`라는 값을 참조할 수 있게 된다.

이 수준의 부정합은 사용자 B가 트랜잭션을 시작하고 `Toto`를 검색했는데 일치하는 결과가 없으나, 사용자 A가 사원번호가 50000인 사원의 이름을 `Toto`로 변경하고 커밋했을 때이다. 이때 사용자 B가 똑같은 쿼리로 다시 조회하면 이번에는 1건이 조회된다.
사용자 B가 하나의 트랜잭션 내에서 똑같은 `selete` 쿼리를 실행했을 때 서로 다른 결과를 가져오는 **NON_REPEATABLE READ** 가 발생한다.

### REPEATABLE READ
---
바이너리 로그를 가진 MySQL 서버에서는 최소 이 수준 이상의 격리 수준을 사용해야 한다.
InnoDB 스토리지 엔진은 트랜잭션이 `rollback` 될 가능성에 대비하여 변경되지 전 레코드를 언두 공간에 백업해두고 실제 레코드 값을 변경한다. 이를 [[MVCC]]라 한다.

이 수준에서는 MVCC를 위해 언두 영역에 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있게 보장한다.

모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가진다. 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함되어 있다. REPEATABLE READ 격리 수준에서는 MVCC를 보장하기 위해 **실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다.**

이 수준의 부정합은 PHANTOM READ가 있다. `select ... for update` 쿼리를 사용하는 경우 레코드에 쓰기 잠금을 걸어야 하는데 언두 레코드에는 잠금을 걸 수 없다. 따라서 `select ... for update`나 `select ... lock in shar mode`로 조회되는 레코드는 변경 전 데이터가 아닌 현재 레코드의 값을 가져오게된다.

다만 잠금을 동반한 `select` 쿼리는 예외적인 상황이므로 일반적인 `seletct`에서는 PHANTOM READ 현상이 발생하지 않는다.