MySQL의 잠금과 별개로 레코드 기반의 잠금 방식을 탑재하고 있다.

### 레코드 락
----
레코드 자체가 아닌 인덱스의 레코드를 잠근다. 인덱스가 없어도 클러스터 인덱스를 이용해 잠금을 설정한다.

### 갭 락
---
레코드와 인접한 레코드 사이의 간격을 잠근다. 레코드와 레코드 사이 새로운 레코드가 생성되는 것을 제어한다.

### 넥스트 키 락
---
레코드 락과 갭 락을 합쳐 놓은 형태의 잠금이다.
바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도락 보장하는 것이 주목적이다.(???)

### 자동 증가 락
----
insert, replace 쿼리 문과 같이 새로운 레코드를 저장하는 쿼리에서 필요하다. 다른 잠금과 달리 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 즉시 해제된다.
테이블에 단 하나만 존재하는 락이기에 동시에 insert 쿼리가 실행되면 나머지 쿼리는 락을 기다려야 한다. 명시적으로 AUTO_INCREMENT 값을 설정하더라도 락을 건다.

`innodb_autoinc_lock_mode` 시스템 변수에 따라 작동 방식이 변경된다.

8.0 버전부터 기본값이 2로 설정되어 있다. 경량화된 래치(뮤텍스)를 사용하며 연속된 자동 증가 값을 보장하지는 않지만 유니크한 값이 생성된다는 것을 보장한다. STATEMENT 포맷의 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있어 주의해야 한다.
8.0 부터는 바이너리 로그 포맷이 ROW가 기본값이며 STATEMENT 포맷의 바이너리 로그를 사용하는 경우 1로 변경해서 사용할 것을 권장한다고 한다.

### 인덱스와 잠금
---
InnoDB의 잠금은 인덱스를 이용한다. 따라서 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드에 모두 락을 걸어야 한다.

만일 `update` 문을 위해 적절한 인덱스가 준비되어 있지 않다면 각 클라이언트간의 동시성이 상당히 떨어진다. 한 세션에서 `update` 작업을 수행 하는 중, 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생할 수 있다.

인덱스가 하나도 없다면 테이블 풀 스캔을 통해 `update` 작업을 수행한다. 이 과정에서 테이블에 있는 수십만 건의 모든 레코드를 잠그게 될 것이다.

### 레코드 수준의 잠금 확인 및 해제
---
공란

### 공유락과 배타락
---
- 공유략은 락을 가지고 있는 트랜잭션이 row를 읽을 수 있도록(read) 허용합니다.
- 배타락은 락을 가지고 있는 트랜잭션이 row를 업데이트(update)하거나 삭제(delete)할 수 있도록 허용합니다.

만일 트랜잭션 `t1`이 row `r`에 대해 S-락을 보유하고 있는 경우, 트랜잭션 `t2`가 `r`에 대해 S-락을 요청하는 경우 즉시 획득할 수 있습니다. 하지만 X-락을 요청하는 경우 `t2`는 락을 획득할 수 없습니다.

만약 트랜잭션 `t1`이 row `r`에 대해 X-락을 보유하고 있는 경우, 트랜잭션 `t2`가 row `r`에 대해 S-락 또는 X-락을 요청해도 락을 획득할 수 없습니다. 대신 `t1`이 `r`에 대한 락을 해제할 때까지 대기합니다. 