#### 접근 제어자
---
접근 제어자는 객체 내부의 데이터를 숨기고 협력에 필요한 오퍼레이션을 선택적으로 노출하기 위해 사용할 수 있습니다. 자바는 다음과 같은 4가지 접근 제어자를 제공합니다.
##### private
- 모든 외부 호출을 막는다.
##### default(package-private)
- 동일한 패키지 안에서의 호출만 허용한다.
##### protected
- 동일한 패키지 안에서의 호출을 허용한다. 다른 패키지에서의 상속 관계에서 호출을 허용한다.
##### public
- 모든 외부 호출을 허용한다.

#### 객체, 클래스, 인스턴스
---
##### 객체
데이터를 가지고 스스로의 행위를 결정하는 것을 객체라 합니다.

##### 클래스
클래스는 객체를 만들기 위한 설계도를 ㅁ

##### 인스턴스
인스턴스는 클래스를 가지고 만든 객체를 지칭합니다.

#### 오버로딩과 오버라이딩
---
오버로딩과 오버라이딩은 다형성을 구현하기 위한 방법입니다.
##### 오버로딩(Overloading)
오버로딩은 동일한 이름을 가진 여러 메서드를 만드는 것입니다. 동일한 이름에 다양한 파라미터를 선언할 수 있지만 반환 타입은 달라질 수 없습니다.

##### 오버라이딩(Overriding)
오버라이딩은 상속, 구현 관계에 있는 상위 타입의 메서드를 재정의 하는 것입니다. 이를 통해 동일한 타입 계층을 형성하고 있는 다양한 객체들과 협력할 수 있습니다.

#### 자바의 자료형
---
자바의 자료형은 기본형과 참조형으로 나뉩니다.
##### 기본형(Primitive type)
기본형은 변수에 값을 직접 집어넣습니다. `int`, `long`, `double`, `boolean`, `byte`, `char`, `float`, `short` 8가지가 있습니다.

##### 참조형(Reference type)
자바에서 기본형을 제외한 모든 것은 참조형으로 구현되어 있습니다. 이들은 객체나 배열을 참조하기 위한 주소를 저장합니다.

##### Call by value? Call by reference?
자바에서는 개발자가 명시적으로 포인터를 다룰 수 없습니다. 자바는 항상 변수의 값을 복사해서 대입하는 Call by value로 동작합니다. 다만 기본형은 변수에 들어 있는 실제 값을 복사해서 대입하고 참조형은 주소값을 복사해서 대입하는 차이가 존재합니다.

#### 인터페이스와 추상 클래스
---
##### 인터페이스(interface)
인터페이스는 별도의 데이터를 가지고 있지 않고 모든 메서드가 추상 메서드로 선언된 것을 인터페이스라고 합니다.

##### 추상 클래스(abstract class)
추상 클래스는 내부에 데이터를 가지고 일부 메서드가 추상 메서드로 선언된 것을 말합니다.

#### 체크 예외와 언체크 예외
---
##### 체크 예외(Checked Exception)
체크 예외는 컴파일러가 체크하는 예외입니다. 이는 개발자가 명시적으로 처리해야 하는 예외입니다. 만일 잡아서 처리하지 않는 경우 메서드를 호출한 곳으로 던지게 됩니다. 어떠한 곳에서도 예외를 잡아서 처리하지 않고 `main()`까지가면 예외 로그를 출력하면서 시스템이 종료됩니다.

**체크 예외의 장단점**
- 장점: 컴파일러가 체크하기 때문에 개발자가 실수로 예외를 누락하지 않도록 합니다.
- 단점: 개발자는 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 한다.

**체크 예외의 문제점**
체크 예외를 잡아서 처리하지 않고 예외를 공통으로 잡아서 처리하려는 경우 예외 발생 지점부터 공통 처리 부분까지 던지는 예외에 대한 의존성이 발생하게 됩니다. 해당 예외가 특정 기술에 의존하는 예외인 경우 사용하는 기술이 변경된다면 해당 예외에 의존하고 있는 모든 계층에 변경의 파급 효과가 발생하게 됩니다.
##### 언체크 예외(Unchecked Exception)
언체크 예외는 컴파일러가 체크하지 않는 예외입니다. 개발자가 잡아서 처리하지 않고 던지는 경우 별도로 `throws`를 선언하지 않고 생략할 수 있습니다.

**언체크 예외의 장단점**
- 장점: 신경쓰고 싶지 않은 예외를 무시할 수 있습니다.
- 단점: 컴파일러가 체크하지 않기 때문에 개발자의 실수로 처리 로직을 누락할 수 있습니다.

대부분의 경우 런타임 예외를 많이 활용하며 개발자가 반드시 잡아서 처리해야 하는 중요한 비즈닉스 예외인 경우 체크 예외를 사용할 수 있습니다.

#### 예외 계층 구조
---
![[예외 계층.png]]
<출처: 김영한님의 스프링 DB 1편>

예외 또한 객체이기 때문에 최상위에 Object가 있고 그 하위에 최상위 예외인 Throwable이 있습니다. 그 하위에 Exception과 Error가 있습니다.

자바에서 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 오류를 Error라고 합니다. 이외에 개발자의 실수로 발생하며 애플리케이션에서 처리할 수 있는 오류를 Exception이라고 합니다. 그리고 Exception 하위에 컴파일러가 체크하지 않는 RuntimeException이 존재합니다.

#### static
---
`static`은 변수나 메서드, 클래스에 사용할 수 있는 키워드입니다.

`static`을 사용해서 선언한 변수를 클래스 변수 또는 정적 변수라고 하며 메서드 영역의 static 영역에서 관리합니다. 해당 클래스가 JVM에 로딩 되는 순간 생성되고 JVM이 종료될 때까지 생명주기가 이어집니다. 

`static`을 사용해서 선언한 메서드를 클래스 메서드 또는 정적 메서드라 합니다. 메서드 영역의 static 영역에서 관리합니다. 정적 메서드 내부에서는 인스턴스 변수나 인스턴스 메서드를 사용할 수 없으며 정적 메서드, 정적 변수만 사용할 수 있습니다. 반대로 다른 모든 곳에서는 정적 메서드를 호출할 수 있습니다.
##### main()
`main()` 메서드는 프로그램을 시작하는 시작점입니다. `static`이기 때문에 별도의 객체 생성없이 시작할 수 있습니다.

#### final
---
`final` 키워드는 변수, 메서드, 클래스에 사용할 수 있는 키워드입니다.

`final` 변수는 생성자 혹은 필드 초기화를 통해서 최초 한 번만 할당할 수 있습니다. 한번 할당한 뒤로는 값을 재할당할 수 없습니다. `final` 변수는 힙 영역에 생성되는 인스턴스마다 메모리가 할당되기 때문에 필드 초기화를 하는 경우 `static` 키워드와 함께 상수로 선언하는 편이 좋습니다.


#### generic
---
자바에서 제네릭은 클래스나 메서드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법입니다. 이렇게 컴파일 시에 미리 타입 체크를 수행하면 다음과 같은 장점을 가집니다.

- 클래스나 메서드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있습니다.
- 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있습니다.

제네릭은 클래스에 T 타입 변수를 사용해 선언할 수 있으며 이는 임의의 참조형 타입을 의미합니다.
```java
public class Hello<T> {
	T data;

	public T getDate() {
		return data;
	}
}
```

제네릭 클래스를 생성할 때는 타입 변수 자리에 실제 사용할 타입을 명시하면 됩니다. 자바 7부터는 인스턴스 생성 시 타입을 추정할 수 있는 경우 타입을 생략할 수 있습니다.
```java
Hello<Integer> hello = new Hello<>();
```

제네릭은 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변홥됩니다. 컴파일된 class 파일에는 어떠한 제네릭 타입도 포함되지 않습니다.
##### 타입 변수 제한하기
특정 클래스의 하위 타입만 사용하도록 제한하기 위해서는 다음과 같이 `extends`를 사용할 수 있습니다.
```java
public class Hello<T extends Hi> {...}
```
##### 와일드카드
