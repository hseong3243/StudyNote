#### equals()와 hashCode()
---
##### equals()
`equals()` 메서드는 해당 객체와 전달받은 객체가 동일한지 비교하는 메서드입니다. 자식 클래스에서 `equals()`를 별도로 재정의하지 않으면 주소값을 비교합니다. 만일 객체의 동등성을 비교하고자 한다면 자식 클래스에서 이를 재정의해야 합니다.
##### hashCode()
`hashCode()` 메서드는 객체의 주소값을 해싱한 해시 코드를 반환합니다. 

만일 `equals`를 재정의 하려는 경우 항상 `hashCode`도 함께 재정의해줘야 합니다. `equals`만 재정의한다면 컬렉션 프레임워크를 사용할 때 의도치 않은 문제가 발생할 수 있습니다.

HashSet과 같은 컬렉션은 객체가 논리적으로 동일한지 비교할 때 먼저 `hashCode()`를 호출해서 리턴 값을 가지고 동일한 객체가 있는지 비교합니다. 만일 해시코드가 있다면 그 다음 `equals()`를 호출해서 리턴 값을 비교하여 논리적으로 같은 객체인지 판단합니다.

따라서 HashSet과 같은 컬렉션에서 중복 없이 새로운 요소를 추가하기 위해서는 `equals()`와 `hashCode()` 모두 오버라이딩해야 합니다.

#### String
---
자바에서 문자열은 String 타입의 변수를 선언하여 리터럴로 할당할 수 있습니다. String 객체가 힙 영역에 생성되며 변수는 해당 객체는 주소값을 가지게 됩니다.
```java
String str1 = "문자열";
String str2 = new String("문자열");
```

`new` 연산자를 사용하여 생성할 수도 있습니다. 그러나 동일한 리터럴로 사용할 때는 변수에 동일한 주소값이 할당되지만 `new` 연산자를 사용하는 경우 새로운 String 객체가 생성되어 다른 주소값이 할당됩니다. 따라서 문자열 비교를 수행하는 경우 `equals()` 메서드를 사용해서 비교를 수행해야 합니다.

#### List
---
List는 동일한 요소의 중복을 허용하며 순서가 있는 요소의 집합입니다.
##### ArrayList
ArrayList 클래스는 배열을 이용하여 구현된 List입니다. 배열을 이용하기 때문에 인덱스를 이용해 배열 요소에 빠르게 접근할 수 있습니다. 그러나 배열은 크기를 변경할 수 없으므로 크기를 늘리기 위해서는 새로운 배열을 생성하고 기존 요소들을 복사해야 합니다.
##### LinkedList
LinkedList 클래스는 이중 연결 리스트를 이용하여 구현된 List입니다. 각각의 요소마다 데이터와 다음 요소, 이전 요소를 가리키는 참조를 가집니다. 

#### Set
---
Set은 동일한 요소의 중복을 허용하지 않은 순서가 없는 요소의 집합입니다.
##### HashSet
HashSet은 `hashCode()`와 `equals()`를 이용하여 동등 객체인지 비교를 수행합니다. 만약 동등한 객체가 존재하는 경우 저장하지 않습니다.
##### TreeSet
TreeSet은 데이터가 정렬된 상태로 저장되는 이진 검색 트리(BST, Binary Search Tree)의 형태로 요소를 저장합니다.  TreeSet 클래스는 기존 이진 검색 트리의 성능을 향상시킨 레드-블랙 트리(Red-Black Tree)로 구현합니다.

#### Map
---
Map은 key-value 쌍의 데이터를 저장하며 키의 중복을 허용하지 않지만 값의 중복은 허용하는 요소의 집합입니다.
##### HashMap
HashMap은 `hashCode()`와 `equals()`를 이용하여 동일한 키가 존재하는지 비교합니다. 
##### HashTable
HashTable은 메서드 전체에 synchronized 키워드를 이용하여 동기화를 수행합니다. 이 때문에 쓰레드 안전하긴 하지만 성능이 떨어진다는 단점이 있습니다.
##### TreeMap
##### ConcurrentHashMap
ConcurrentHashMapd은 HashTable과 달리 synchronized 키워드가 메서드 전체에 붙어 있지 않고 `put()` 메서드 안에 synchronized 블럭이 존재합니다. 읽기 작업에서는 여러 쓰레드가 동시에 읽을 수 있지만 쓰기 작업시에는 특정 버킷에 대한 Lock을 사용합니다. 때문에 같은 버킷이 아니라면 Lock을 기다릴 필요가 없다는 특징이 있습니다.