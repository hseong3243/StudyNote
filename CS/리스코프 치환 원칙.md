> 컴퓨터 프로그램에서 자료형 S가 자료형 T의 서브타입이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙이다. (출처: 위키백과)

`DiscountPolicy`라는 클래스는 할인률을 계산하기 위한 메서드를 가지고 있고 `Movie`는 이를 의존하고 있습니다. `Movie`는 `AmountDiscountPolicy`나 `PercentDiscountPolicy` 둘 중 무엇과도 협력할 수 있습니다. 둘 다 각자의 알고리즘을 이용해서 할인률을 계산할 것입니다.
![[상속.png]]

이처럼 자식 클래스는 부모 클래스가 하는 일을 동일한 방식으로 처리할 수 있어야 합니다. 물론 자식마다 세부적인 구현사항은 달라질 수 있습니다. 오브젝트에서는 리스코프 치환 원칙은 상속을 사용하기 위한 가이드라인이며 자식 클래스가 부모 클래스를 대체하기 위해서는 항상 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다고 합니다. 만일 이러한 가이드라인을 어기면 어떻게 될까요?

## 왜 리스코프 치환 원칙을 준수해야 할까?
Java의 `Stack`은 리스코프 치환 원칙을 어기는 대표적인 예입니다. `Stack`을 사용할 적에 우리는 LIFO를 구현한 자료구조를 기대합니다. 하지만 Java의 `Stack`은 `Vector`를 상속하도록 만들어졌습니다. 이 때문에 `Stack`에는 `insertElementAt()`이나 `remove()`와 같이 임의의 위치에 요소를 추가하거나 제거하는, 클라이언트가 `Stack`에 기대하는 것과는 다른 메서드가 포함되었습니다.
![[스택과 벡터.png]]

`Stack`을 사용하는 클라이언트는 LIFO 자료구조에 맞는 행위를 기대하고, `Vector`를 사용하는 클라이언트는 동적인 배열에 맞는 행위를 기대합니다. `Stack`은 결코 `Vector`를 대체할 수 없습니다. 그렇기 때문에 리스코프 치환 원칙은 언제나 클라이언트의 관점에서 바라보아야 합니다. 상속 관계에 있는 클래스는 언제나 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을 때만 올바릅니다.

이처럼 리스코프 치환 원칙은 우리에게 올바른 상속 구조를 구현하기 위한 가이드라인을 제공합니다. 자식 클래스가 부모 클래스를 안정적으로 대체할 수 있다면 클라이언트의 코드는 어떠한 변경도 없이 자식 클래스와 협력할 수 있습니다.

