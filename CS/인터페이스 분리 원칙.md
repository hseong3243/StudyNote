> 인터페이스 분리 원칙은 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다. (출처: 위키백과)

## 왜 인터페이스 분리 원칙을 준수해야 할까?
#### 인터페이스 오염
여기 `유튜브 시청자`라는 클라이언트가 있습니다. 클라이언트는 `유튜브 머신` 인터페이스를 이용하여 특정한 구현에 의존하지 않고 해당 인터페이스를 구현하는 객체와 협력할 수 있습니다. 
![[인터페이스 오염.png]]

어느날 `유튜브 시청자`는 `유튜버` 활동을 통해 수익 창출을 해보기로 결심하였습니다. 이를 위해 `유튜브 머신`에  `영상 업로드`, `영상 관리`와 같은 새로운 메서드를 추가하였습니다. 
![[인터페이스 오염2.png]]

이제 `유튜브 머신`을 구현하는 구현체들은 새롭게 추가된 메서드들을 강제로 구현해야 합니다. 여기서 문제가 발생합니다. `고사양 컴퓨터`에는 이러한 메서드의 구현부를 추가하는 것이 의도된 것일 수 있습니다. 하지만 `태블릿`은 `영상 업로드`, `영상 관리`와 같은 메서드를 가지게 되는 것을 원치 않았음에도 이를 강제로 구현해야 상황이 발생합니다.

이처럼 새로운 기능이 추가되면서 인터페이스가 점점 비대해지다 보면 원치 않는 기능을 강제로 구현해야 하는 상황이 발생할 수 있습니다. 이러한 상황을 방지하기 위해서는 ISP를 적용하여 인터페이스를 작게 나누어야 합니다. 인터페이스를 작게 나눈 다음에는 다음과 같이 다중 상속을 이용해서 문제를 해결할 수 있을 겁니다.
![[인터페이스 오염4.png]]
#### 재컴파일
클린 아키텍처에서는 클라이언트가 자신이 사용하지 않는 메서드에 의존하도록 강제되었을 때, 다른 클라이언트가 해당 메서드에 가하는 변경에 영향을 받게 된다고 말하고 있습니다.

`ClientA`와 `ClientB`가 의존하는 `Something`이라는 클래스가 있다고 해봅시다. `ClientA`는 오직 `clientAUse`만 사용하고, `ClientB`는 오직 `clientBUse`만 사용하고 있습니다. 두 클라이언트는 각각 자신이 사용하지 않는 메서드에 의존하고 있기 때문에 인터페이스 분리 원칙을 위반하였습니다.
![[ISP 위반.png]]

정적 타입 언어의 경우 이러한 상황에서 `ClientB`가 사용하고 있는 `clientBUse`의 시그니처가 변경되는 경우 변경이 발생한 `Something`과  이에 의존하고 있는 `ClientA`와 `ClientB` 모두 다시 컴파일을 수행해야 합니다.

다만, 자바의 경우 호출할 정확한 메서드를 런타임에 결정하는 late binding 덕분에 다른 정적 타입 언어와는 다른 양상을 보입니다. 의존하고 있는 클래스의 변경이 발생하더라도 현재 클라이언트가 사용하고 있는 메서드와 관계없다면 다시 컴파일을 수행할 필요가 없다고 합니다.