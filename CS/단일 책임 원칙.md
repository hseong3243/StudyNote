> 단일 책임 원칙(single responsibility principle)이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다. (출처: 위키백과)

클린 아키텍처의 저자 밥 아저씨는 SRP에 대해서 다음과 같이 표현합니다.

하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

여기서 액터(actor)는 시스템이 동일한 방식으로 변경되기를 원하는 한 명 이상의 사람들을 가리킵니다. 또한, 모듈은 소스 파일 혹은 함수와 데이터 구조로 응집된 집합을 가리킵니다. 클래스, 패키지, 라이브러리 등 독립적이고 재사용 가능하게 응집된 단위입니다.

## 왜 중요한가?
그렇다면 어째서 단일 책임 원칙이 중요할까요? 밥 아저씨가 제시해주는 예제를 가지고 알아보겠습니다.
#### 우발적 중복
여기 `Employee`라는 클래스가 있습니다. 해당 클래스가 가지고 있는 두 가지 메서드는 서로 다른 두 명의 액터를 책임지고 있습니다. `caculatePay()`는 회계팀에서 기능을 정의하고 사용합니다. `reportHours()`는 인사팀에서 기능을 정의하고 사용합니다. 두 메서드 모두 업무 시간을 계산하기 위해 `regularHours()` 메서드를 호출하고 있습니다.
![[우발적 중복 변경 전.png]]

```java
public class Employee {
	...

	public Payment calculatePay() {
		...
		int regularHours = regularHours();
		...
	}

	
	private int regularHours() {
		...
	}

	...

	public Report reportHours() {
		...
		int regularHours = regularHours();
		...
	}
}
```

만약 회계팀에서 업무 시간을 계산하기 위한 로직을 변경한다고 가정해봅시다. 해당 업무를 수행하는 개발자는 `calculatePay()` 내부에서 `regularHours()`라는 메서드를 호출하는 것을 발견하였습니다. 하지만 `reportHours()`에서도 동일한 메서드를 호출한다는 것을 발견하지 못하였습니다.
![[우발적 중복 변경 후.png]]

회계팀의 변경된 기능은 의도한대로 잘 동작하였고 배포를 끝마쳤습니다. 그러나 인사팀의 보고서는 엉터리 수치가 포함되어 잘못된 데이터 범벅이 됩니다. 서로 다른 두 액터가 동일한 코드를 의존하고 있었기 이와 같은 문제가 발생하였습니다.
#### 병합
이번에는 회계팀과 인사팀이 둘 모두 모종의 이유로 `Employee` 클래스의 코드를 변경해야 한다고 생각해봅시다. 둘의 작업은 동시에 일어나고 이들의 변경사항은 서로 충돌합니다. 코드 충돌을 해결하는 과정은 번거롭고 실수로 다른 사람의 변경사항을 건드릴지도 모릅니다.
![[병합.png]]

이처럼 서로 다른 목적을 가지고 동일한 소스 파일을 변경하려는 경우 여러 징후들이 발생하게 됩니다. 이를 해결하기 위한 방법은 각각의 메서드를 서로 다른 클래스로 이동시키는 것입니다. 
```java
public class Employee {
	...
}

public class PayCalculator {
	...

	public Payment calculatePay() {
		...
	}

	private int regularHours() {
		...
	}
}

public class HourReporter {
	...
	
	public Report reportHours() {
		...
	}

	private int regularHours() {
		...
	}
}
```

## 참고
클린 아키텍처