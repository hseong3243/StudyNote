#### ORM
---
ORM은 객체와 관계형 데이터베이스 간의 차이를 중간에서 해결해주는 프레임워크입니다.

#### JPA
---
JPA는 자바 진영의 ORM 기술 표준입니다.
##### 장점
- 단순한 CRUD를 JPA가 알아처 처리해주기 때문에 생산성이 향상됩니다.
- 새로운 필드를 추가하더라도 JPA가 알아서 처리해주기 때문에 유지보수하기 좋습니다.
- 한 번 조회한 데이터는 영속성 컨텍스트에 캐시되기 때문에 성능상의 이점을 가집니다.
- 특정 데이터베이스 기술에 종속되지 않습니다. 

#### 엔티티 매니저(EntityManager)
---
엔티티의 저장, 수정, 삭제, 조회 등 엔티티와 관련된 모든 일을 처리합니다. 엔티티를 저장하는 가상의 데이터베이스라고 생각할 수 있습니다. 엔티티 매니저는 여러 스레드에서 동시 접근하면 동시성 문제가 발생할 수 있으므로 스레드 간 공유해서는 안됩니다.

#### 영속성 컨텍스트(Persistence Context)
---
영속성 컨텍스트는 엔티티가 저장되는 공간입니다. 영속성 컨텍스트의 생존 범위는 트랜잭션의 범위와 동일합니다. 즉, 트랜잭션이 다르면 서로 다른 영속성 컨텍스트에 접근합니다.
##### 특징
- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분합니다.
- 영속성 컨텍스트에 저장된 엔티티는 트랜잭션이 커밋되는 순간 데이터베이스에 반영되며 이를 플러시(flush)라 합니다.
##### 1차 캐시
엔티티 조회를 수행할 때 1차 캐시에 엔티티가 없으면 엔티티 매니저는 데이터베이스를 조회해서 엔티티를 생성합니다. 그리고 1차 캐시에 저장한 후 영속 상태의 엔티티를 반환합니다. 따라서 반복해서 동일한 엔티티를 조회하는 경우 같은 트랜잭션에서는 항상 동일한 객체를 조회할 수 있습니다.
##### 쓰기 지연 저장소
엔티티 매니저는 트랜잭션 커밋 전까지 내부 쿼리 저장소에 Insert 쿼리를 모아둡니다. 이를 트랜잭션을 지원하는 쓰기 지연이라 합니다.

단, 기본키 생성 전략이 IDENTITY 인 경우 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있습니다. 따라서 `em.persist()` 또는 `repository.save()` 메서드를 호출하는 즉시 insert 쿼리가 데이터베이스에 전달됩니다. 따라서 트랜잭션을 지원하는 쓰기 지연이 동작하지 않습니다.
##### 더티 체킹
JPA는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사한 스냅샷을 저장해둡니다. 그리고 플러시 시점에 스냅샷과 엔티티를 비교해서 변경된 엔티티를 찾아냅니다.

JPA의 업데이트 쿼리 생성 전략은 모든 필드를 업데이트하는 것입니다. 데이터베이스에 보내는 데이터 전송량은 증가하는 단점이 있지만 애플리케이션 로딩 시점에 수정 쿼리를 미리 생성해두고 재사용할 수 있는 점, 데이터베이스에 동일한 쿼리를 보내면 이전에 한 번 파싱된 쿼리를 재사용할 수 있는 점과 같은 장점이 있다고 합니다.

#### 준영속 상태의 엔티티 병합
---
준영속 상태의 엔티티는 1차 캐시가 관리하고 있지 않습니다. 따라서 `merge()`를 호출하는 경우 데이터베이스에서 엔티티를 먼저 조회해오고 준영속 상태의 엔티티 값을 밀어넣습니다. 밀어넣는 과정에서 준영속 상태의 엔티티 변경 사항이 영속 상태의 엔티티에 적용됩니다.

#### 일대일 양방향 관계 주의점
---
프록시를 사용할 때 외래키를 관리하지 않는 일대일 관계는 지연 로딩으로 설정해도 즉시 로딩됩니다. 이는 프록시의 한계 때문이라고 합니다.

#### 컬렉션 래퍼
---
하이버네이트는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 하이버네이트 내장 컬렉션으로 변경합니다. 이를 컬렉션 래퍼라합니다. 컬렉션 래퍼에서 실제 데이터를 조회하는 시점은 `list.get(0)`와 같이 실제 데이터를 조회할 때 데이터베이스를 조회해서 초기화합니다.

#### 영속성 전이
---
##### CascadeType.PERSIST
해당 옵션을 사용하면 부모 엔티티를 저장할 때 연관된 자식 엔티티도 함께 영속화합니다.
##### CascadeType.REMOVE
해당 옵션을 사용하면 부모 엔티티 삭제 시 연관된 자식 엔티티도 함께 삭제합니다. 단, 외래키 제약조건을 고려하여 자식 먼저 삭제하고 부모를 삭제합니다.
##### 고아 객체
부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 고아 객체 제거(orphanRemoval)이라 합니다. 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아로 보고 삭제하는 기능입니다.

#### 스프링 데이터 JPA
---
스프링 데이터 JPA는 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트입니다.
##### 공통 인터페이스 기능
스프링 데이터 JPA는 간단한 CRUD 기능을 공통으로 처리하는 `JpaRepository` 인터페이스를 제공합니다.
##### 쿼리 메소드 기능
메서드 이름만으로 쿼리를 생성하는 기능을 가지고 있으며 메서드를 선언하면 적절한 JPQL 쿼리를 생성해서 실행해줍니다.

#### N + 1
---
조회한 엔티티가 10개일 때 조회한 데이터의 수만큼 다시 SQL을 사용해서 조회하는 것을 N+1 문제라고 합니다. 이를 해결하기 위한 방법으로는 페치 조인과 `@BatchSize`가 있습니다.

#### OSIV(Open Session In View)
---
영속성 컨텍스트를 뷰까지 열어두는 것입니다. 스프링이 제공하는 OSIV를 사용하면 트랜잭션이 종료되어도 영속성 컨텍스트는 종료되지 않습니다. 트랜잭션 범위 바깥에서 엔티티를 변경하고 플러시하는 경우 예외가 발생하며 단순 조회만 가능합니다.

그러나 컨트롤러에서 엔티티를 변경하고 비즈니스 로직을 호출하는 경우에는 변경 내용이 데이터베이스에 반영될 수 있습니다.

#### 프록시 비교
---
엔티티의 프록시는 상속으로 만들어집니다. 따라서 == 비교 시 false를 리턴하기 때문에 equals를 오버라이딩 하는 경우 instanceof를 사용해야 합니다. 또한 프록시 멤버변수에 직접 접근하는 경우 아무런 값을 획득할 수 없기 때문에 getter를 사용해서 접근해야 합니다.

## 참고
---
김영한님의 자바 ORM 표준 JPA 프로그래밍